---
title: "GSE158422: DNA methylation in Lung squamous cell carcinoma - gene methylation enrichment analysis"
author: "The GMEA team"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    fig_width: 7
    fig_height: 7
theme: cosmo
---

## Introduction

Functional class sorting is widely used for pathway analysis using tools like GSEA,
yet there is no consensus in how this can be conducted for Illumina Infinium
methylation array data.

Here we propose a simple approach which involves the following:

1. Limma test on probes.

2. For each gene, calculate the median t-statistic from step 1.

3. Use this median t-stat in Camera pre-ranked test for gene sets.

In this example, I'm using matched infinium EPIC 850k data from (n=37) normal and lung cancer samples (GSE158422).
The data was previously preprocessed and normalised using the minfi package (see the folder called "misc").

Here the gene sets are obtained from Reactome.

## Requirements

This analysis was run on a 8C/16T computer with 64GB RAM running at 3.8 GHz.
This workflow used 34 GB RAM and took
RAM usage can be moderated by reducing the parallel core count.

```{r,packages}

suppressPackageStartupMessages({
  library("limma")
  library("eulerr")
  library("IlluminaHumanMethylation450kmanifest")
  library("IlluminaHumanMethylationEPICanno.ilm10b4.hg19")
  library("tictoc")
  library("mitch")
  library("kableExtra")
  library("beeswarm")
})

CORES=12

```

## Load data

* annotations

* probe sets

* gene sets

* design matrix

* mval matrix

```{r,annotation}

anno <- getAnnotation(IlluminaHumanMethylationEPICanno.ilm10b4.hg19)
myann <- data.frame(anno[,c("UCSC_RefGene_Name","Regulatory_Feature_Group","Islands_Name","Relation_to_Island")])

gp <- myann[,"UCSC_RefGene_Name",drop=FALSE]
gp2 <- strsplit(gp$UCSC_RefGene_Name,";")
names(gp2) <- rownames(gp)
sets <- split(rep(names(gp2), lengths(gp2)), unlist(gp2))

summary(unlist(lapply(sets,length)))

genesets <- gmt_import("https://ziemann-lab.net/public/gmea_prototype/ReactomePathways.gmt")

if (!file.exists("GSE158422_design.rds")) {
  download.file("https://ziemann-lab.net/public/gmea_prototype/GSE158422_design.rds", "GSE158422_design.rds")
}
design <- readRDS("GSE158422_design.rds")

if (!file.exists("GSE158422_design.rds")) {
 download.file("https://ziemann-lab.net/public/gmea_prototype/GSE158422_mx.rds","GSE158422_mx.rds")
}
mval <- readRDS("GSE158422_mx.rds")

boxplot(list("tumor"=matrix(colMeans(mval),ncol=2)[,1],"normal"=matrix(colMeans(mval),ncol=2)[,2]),
  main="mean probe methylation mval")

```

Reactome pathways were downloaded on the 14th Sept 2023 from MsigDB.

```{r,gsdl}

gs_entrez <- gmt_import("c2.cp.reactome.v2023.1.Hs.entrez.gmt")

gs_symbols <- gmt_import("c2.cp.reactome.v2023.1.Hs.symbols.gmt")

```

# GMEA: all probes

There are two obvious ways to perform GMEA:

1. limma-agg-1stt (la1).
In this approach, the limma test is conducted on probes, followed by aggregation of the differential
methylation t-scores. Each gene gets a median t-stat value which is evaluated downstream by a 1 sample
t-test.

2. agg-limma-1stt (al1).
Here, the probe beta values for each gene are aggregated to a median and then limma is run on these
values.
To determine gene set enrichment, a 1-sample t-test is conducted.

## LA: limma aggregate 1-sample t-test all probes

```{r,probelimma1}

sex <- as.data.frame(design)$sex
tumor <- as.data.frame(design)$tumor
patient <- as.character(unlist(lapply(1:ncol(mval),function(i) {c(i,i)})))
patient <- head(patient,ncol(mval))
design <- model.matrix(~ patient + tumor )

fit.reduced <- lmFit(mval,design)
fit.reduced <- eBayes(fit.reduced)
summary(decideTests(fit.reduced))
dm <- topTable(fit.reduced,coef=4, number = Inf)
dm <- merge(myann,dm,by=0)
dm <- dm[order(dm$P.Value),]
rownames(dm) <- dm$Row.names
dm$Row.names=NULL

hist(dm$t,breaks=30,main="all probes")
hist(subset(dm,Relation_to_Island=="Island")$t,main="CpG island")
hist(subset(dm,Relation_to_Island=="N_Shore")$t,main="CpG shore")
hist(subset(dm,Relation_to_Island=="N_Shelf")$t,main="CpG shelf")

hist(subset(dm,Regulatory_Feature_Group=="",main="No genomic feature")
hist(subset(dm,Regulatory_Feature_Group=="Promoter_Associated")$t,main="promoter")
hist(subset(dm,Regulatory_Feature_Group=="Gene_Associated")$t,main="gene")
hist(subset(dm,Regulatory_Feature_Group=="Unclassified")$t,main="unclassified")

head(dm) %>%
  kbl(caption="Top DM probes") %>%
  kable_styling("hover",full_width=FALSE)

agg <- function(dm,cores=1) {
  gn <- unique(unlist(strsplit( dm$UCSC_RefGene_Name ,";")))
  gnl <- strsplit( dm$UCSC_RefGene_Name ,";")
  gnl <- mclapply(gnl,unique,mc.cores=cores)
  dm$UCSC_RefGene_Name <- gnl
  l <- mclapply(1:nrow(dm), function(i) {
    a <- dm[i,]
    len <- length(a[[1]][[1]])
    tvals <- as.numeric(rep(a["t"],len))
    genes <- a[[1]][[1]]
    data.frame(genes,tvals)
  },mc.cores=cores)
  df <- do.call(rbind,l)
  keep <- names(which(table(df$genes)>1))
  df <- df[df$genes %in% keep,]
  gn <- unique(df$genes)
  gme_res <- lapply( 1:length(gn), function(i) {
    g <- gn[i]
    tstats <- df[which(df$genes==g),"tvals"]
    myn <- length(tstats)
    mymean <- mean(tstats)
    mymedian <- median(tstats)
    if ( length(tstats) > 2 ) {
      ttest <- t.test(tstats)
      pval <- ttest$p.value
    } else {
      pval = 1
    }
    res <- c("gene"=g,"nprobes"=myn,"mean"=mymean,
      "median"=mymedian, pval=pval)
  } )
  gme_res_df <- do.call(rbind, gme_res)
  rownames(gme_res_df) <- gme_res_df[,1]
  gme_res_df <- gme_res_df[,-1]
  tmp <- apply(gme_res_df,2,as.numeric)
  rownames(tmp) <- rownames(gme_res_df)
  gme_res_df <- as.data.frame(tmp)
  gme_res_df$sig <- -log10(gme_res_df[,4])
  gme_res_df <- gme_res_df[order(-gme_res_df$sig),]
  gme_res_df$fdr <- p.adjust(gme_res_df$pval)
  out <- list("df"=df,"gme_res_df"=gme_res_df)
  return(out)
}

tic()
dmagg <- agg(dm,cores=CORES)
toc()

head(dmagg$gme_res_df,20) %>%
  kbl(caption="top gmea genes (t-test)") %>%
  kable_paper("hover", full_width = F)

```

Check whether the distribution is even - it's not.

```{r,tmeddist}

hist(dmagg$gme_res_df$median,breaks=30) ; grid()

hist(dmagg$gme_res_df$mean,breaks=30) ; grid()

```

1-sample t-test for gene set enrichment.

```{r,t_enrichment_test1}

ttenrich <- function(m,genesets,cores=1) {
  res <- mclapply( 1:length(genesets), function(i) {
    gs <- genesets[i]
    name <- names(gs)
    n_members <- length(which(rownames(m) %in% gs[[1]]))
    if ( n_members > 4 ) {
      tstats <- m[which(rownames(m) %in% gs[[1]]),]
      myn <- length(tstats)
      mymean <- mean(tstats)
      mymedian <- median(tstats)
      wt <- t.test(tstats)
      res <- c(name,myn,mymean,mymedian,wt$p.value)
    }
  } , mc.cores = cores)
  res_df <- do.call(rbind, res)
  rownames(res_df) <- res_df[,1]
  res_df <- res_df[,-1]
  colnames(res_df) <- c("n_genes","t_mean","t_median","pval")
  tmp <- apply(res_df,2,as.numeric)
  rownames(tmp) <- rownames(res_df)
  res_df <- tmp
  res_df <- as.data.frame(res_df)
  res_df <- res_df[order(res_df$pval),]
  res_df$logp <- -log10(res_df$pval )
  res_df$fdr <- p.adjust(res_df$pval,method="fdr")
  res_df[order(abs(res_df$pval)),]
  return(res_df)
}

# try mean and median
m <- dmagg$gme_res_df[,"mean",drop=FALSE]
lares <- ttenrich(m=m,genesets=gs_symbols,cores=CORES)
hist(lares$t_mean)

# need to get the median column before analysis
m <- dmagg$gme_res_df[,"median",drop=FALSE]
lares <- ttenrich(m=m,genesets=gs_symbols,cores=CORES)
hist(lares$t_median)

head(lares,30) %>%
  kbl(caption = "Top significant genesets using LA approach") %>%
  kable_paper("hover", full_width = F)

head(lares[order(-abs(lares$t_median)),],30) %>%
  kbl(caption = "Top effect size genesets using LA approach") %>%
  kable_paper("hover", full_width = F)

lasig <- subset(lares,fdr<0.05)
nrow(lasig)

head(lasig[order(-abs(lasig$t_median)),],30) %>%
  kbl(caption = "Top effect size genesets after FDR filtering using LA approach") %>%
  kable_paper("hover", full_width = F)

plot(lares$t_median,-log10(lares$pval),pch=19,col="gray")
grid()
points(lasig$t_median,-log10(lasig$pval),pch=19,col="red")

```

## AL: Aggregate limma t-test all probes

Determine the median of probe values

```{r,med1}

mx <- mval

gn <- unique(unlist(strsplit( myann$UCSC_RefGene_Name ,";")))
gnl <- strsplit( myann$UCSC_RefGene_Name ,";")
gnl <- mclapply(gnl,unique,mc.cores=CORES)
myann$gnl <- gnl

# compare median and mean based aggregation
mymed <- function(g) {
  probes <- rownames(myann[grep(g,myann$gnl),])
  rows <- which(rownames(mx) %in% probes)
  if ( length(rows) > 1 ) {
    b <- mx[rows,]
    med <- apply(b,2,median)
    med <- matrix(med,nrow=1)
    colnames(med) <- colnames(b)
    rownames(med) <- g
    return(med)
  }
}

med <- mclapply(gn,mymed,mc.cores=CORES)
med <- med[lapply(med,length)>0]
medf <- do.call(rbind,med)

boxplot(list("normal"=matrix(colMeans(mval),ncol=2)[,2],"tumor"=matrix(colMeans(mval),ncol=2)[,1]),
  main="mean mval for control and tumor samples (all probes)")

boxplot(list("normal"=matrix(colMeans(medf),ncol=2)[,2],"tumor"=matrix(colMeans(medf),ncol=2)[,1]),
  main="mean mval for control and tumor samples (gene associated)")

```

Then do a limma test on median gene methylation.
See if it is more robust than other approaches.

```{r,limma1}

fit.reduced <- lmFit(medf,design)
fit.reduced <- eBayes(fit.reduced)
summary(decideTests(fit.reduced))
magg <- topTable(fit.reduced,coef=ncol(design), number = Inf)

hist(magg$t)

head(magg, 30) %>%
  kbl(caption="limma gene methylation results") %>%
  kable_paper("hover", full_width = F)

```

Very curious that the distribution is negatively skewed now.

Let's do another test to see whether this is correct or not.

```{r,test}

mytest <- lapply(1:nrow(medf),function(i) {
  ctl <- matrix(medf[i,],ncol=2)[,2]
  tum <- matrix(medf[i,],ncol=2)[,1]
  tt <- t.test(tum,ctl)
  t=tt$statistic ; p=tt$p.value ; est=rev(tt$estimate)
  names(est) = c("ctl","tum")
  c(t,p,est)
} )

mytest <- as.data.frame(do.call(rbind,mytest))
colnames(mytest) = c("t","p","ctl","tum")
rownames(mytest) <- rownames(medf)
hist(mytest[,"t"])

mytest <- mytest[order(mytest$p),]
head(mytest,20) %>%
  kbl(caption="Top significant differential gene methylation results using dumb test") %>%
  kable_paper("hover", full_width = F)

nrow(subset(mytest,p<0.05 & t>0))
nrow(subset(mytest,p<0.05 & t<0))

```

Hypomethylated genes still outnumber hypermethylated genes.

It does skew downwards after aggregation.

1-sample t-test for enrichment

```{r,ttest}

ttenrich <- function(m,genesets,cores=1) {
  res <- mclapply( 1:length(genesets), function(i) {
    gs <- genesets[i]
    name <- names(gs)
    n_members <- length(which(rownames(m) %in% gs[[1]]))
    if ( n_members > 4 ) {
      tstats <- m[which(rownames(m) %in% gs[[1]]),]
      myn <- length(tstats)
      mymean <- mean(tstats)
      mymedian <- median(tstats)
      wt <- t.test(tstats)
      pval = wt$p.value
      res <- c(name,myn,mymean,mymedian,pval)
    }
  } , mc.cores = cores)
  res_df <- do.call(rbind, res)
  rownames(res_df) <- res_df[,1]
  res_df <- res_df[,-1]
  colnames(res_df) <- c("n_genes","t_mean","t_median","pval")
  tmp <- apply(res_df,2,as.numeric)
  rownames(tmp) <- rownames(res_df)
  res_df <- tmp
  res_df <- as.data.frame(res_df)
  res_df <- res_df[order(res_df$pval),]
  res_df$logp <- -log10(res_df$pval )
  res_df$fdr <- p.adjust(res_df$pval,method="fdr")
  res_df[order(abs(res_df$pval)),]
  return(res_df)
}

m <- as.data.frame(magg$t)
rownames(m) <- rownames(magg)
colnames(m) <- "t"

alres <- ttenrich(m=m,genesets=gs_symbols,cores=CORES)

hist(alres$t_mean)

alsig <- subset(alres,fdr<0.05)

nrow(alsig)

nrow(subset(alsig,t_median>0))

head(alsig[order(-alsig$t_median),],20) %>%
  kbl(caption="hypermethylated pathways") %>%
  kable_paper("hover", full_width = F)

nrow(subset(alsig,t_median<0))

head(alsig[order(alsig$t_median),],20) %>%
  kbl(caption="hypomethylated pathways") %>%
  kable_paper("hover", full_width = F)

```

## Overlap

Use Euler diagrams to find the similarity.
As medians are normally distributed about the zero, one would expect equal numbers of up and down-
methylated gene sets.
Therefore the t-test based approach could be considered better.

```{r,ol1}

lasig_up <- rownames(subset(lasig,t_median>0))
lasig_dn <- rownames(subset(lasig,t_median<0))

alsig_up <- rownames(subset(alsig,t_median>0))
alsig_dn <- rownames(subset(alsig,t_median<0))

v1 <- list("LA up"=lasig_up, "LA dn"=lasig_dn,
  "AL up"=alsig_up,"AL dn"=alsig_dn)

plot(euler(v1),quantities = TRUE)

```

# GMEA: promoter probes only

## Limma-aggregate-1-sample t-test promoter only

```{r,ls_promoter}

dmp <- dm[grep("Promo",dm$Regulatory_Feature_Group),]

tic()
dmpagg <- agg(dmp,cores=CORES)
toc()

head(dmpagg$gme_res_df,20) %>%
  kbl(caption="top gmea genes (t-test)") %>%
  kable_paper("hover", full_width = F)

```

Check whether the distribution is even - it's not.

```{r,laphist}

hist(dmpagg$gme_res_df$median,breaks=30) ; grid()

```

1-sample t-test for gene set enrichment.

```{r,t_enrichment_test1_promoter}

# need to get the median column before analysis
m <- dmpagg$gme_res_df[,"median",drop=FALSE]

tic()
lapres <- ttenrich(m=m,genesets=gs_symbols,cores=CORES)
toc()

head(lapres,30) %>%
  kbl(caption = "Top significant genesets using LA approach for promoters") %>%
  kable_paper("hover", full_width = F)

head(lapres[order(-abs(lapres$t_median)),],30) %>%
  kbl(caption = "Top effect size genesets using LA approach") %>%
  kable_paper("hover", full_width = F)

lapsig <- subset(lapres,fdr<0.05)
nrow(lapsig)

head(lapsig[order(-abs(lapsig$t_median)),],30) %>%
  kbl(caption = "Top effect size genesets after FDR filtering using LA approach for promoters") %>%
  kable_paper("hover", full_width = F)

plot(lapres$t_median,-log10(lapres$pval),pch=19,col="gray")
grid()
points(lapsig$t_median,-log10(lapsig$pval),pch=19,col="red")

```

## AL: Aggregate limma t-test Promoter only

Determine the median of probe values.

```{r,med1p}

gn <- unique(unlist(strsplit( myann$UCSC_RefGene_Name ,";")))
gnl <- strsplit( myann$UCSC_RefGene_Name ,";")
gnl <- mclapply(gnl,unique,mc.cores=CORES)
myann$gnl <- gnl
myannp <- myann[grep("Promot",myann$Regulatory_Feature_Group),]

mxp <- mval[rownames(mval) %in% rownames(myannp),]

mymed <- function(g) {
  probes <- rownames(myannp[grep(g,myannp$gnl),])
  rows <- which(rownames(mxp) %in% probes)
  if ( length(rows) > 1 ) {
    b <- mxp[rows,]
    med <- apply(b,2,median)
    med <- matrix(med,nrow=1)
    colnames(med) <- colnames(b)
    rownames(med) <- g
    return(med)
  }
}

medp <- mclapply(gn,mymed,mc.cores=CORES)
medp <- medp[lapply(medp,length)>0]
medfp <- do.call(rbind,medp)

```

Then do a limma test on median gene methylation.
See if it is more robust than other approaches.

```{r,limma1p}

fit.reduced <- lmFit(medfp,design)
fit.reduced <- eBayes(fit.reduced)
summary(decideTests(fit.reduced))
maggp <- topTable(fit.reduced,coef=ncol(design), number = Inf)

head(maggp, 30) %>%
  kbl(caption="limma gene methylation results") %>%
  kable_paper("hover", full_width = F)

```

1-sample t-test for enrichment promoter.

```{r,ttestp}

m <- as.data.frame(maggp$t)
rownames(m) <- rownames(maggp)
colnames(m) <- "t"

alpres <- ttenrich(m=m,genesets=gs_symbols,cores=CORES)

alpsig <- subset(alpres,fdr<0.05)

nrow(alpsig)

nrow(subset(alpsig,t_median>0))

head(alpsig[order(-alpsig$t_median),],20) %>%
  kbl(caption="hypermethylated pathways") %>%
  kable_paper("hover", full_width = F)

nrow(subset(alpsig,t_median<0))

head(alpsig[order(alpsig$t_median),],20) %>%
  kbl(caption="hypomethylated pathways") %>%
  kable_paper("hover", full_width = F)

```

## Promoter Overlap

Use Euler diagrams to find the similarity.
As medians are normally distributed about the zero, one would expect equal numbers of up and down-
methylated gene sets.
Therefore the t-test based approach could be considered better.

```{r,ol1p}

lapsig_up <- rownames(subset(lapsig,t_median>0))
lapsig_dn <- rownames(subset(lapsig,t_median<0))

alpsig_up <- rownames(subset(alpsig,t_median>0))
alpsig_dn <- rownames(subset(alpsig,t_median<0))

v1 <- list("LA up"=lapsig_up, "LA dn"=lapsig_dn,
  "AL up"=alpsig_up,"AL dn"=alpsig_dn)

plot(euler(v1),quantities = TRUE)

```

## Session information

```{r,save}

save.image("GSE158422_gmea.Rdata")

sessionInfo()

```
