---
title: "GSE158422: DNA methylation in Lung squamous cell carcinoma - gene methylation enrichment analysis"
author: "The GMEA team"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    fig_width: 7
    fig_height: 7
theme: cosmo
---

## Introduction

Functional class sorting is widely used for pathway analysis using tools like GSEA,
yet there is no consensus in how this can be conducted for Illumina Infinium
methylation array data.

Here we propose a simple approach which involves the following:

1. Limma test on probes.

2. For each gene, calculate the median t-statistic from step 1.

3. Use this median t-stat in Camera pre-ranked test for gene sets.

In this example, I'm using matched infinium EPIC 850k data from (n=37) normal and lung cancer samples (GSE158422).
The data was previously preprocessed and normalised using the minfi package (see the folder called "misc").

Here the gene sets are obtained from Reactome.

## Requirements

This analysis was run on a 8C/16T computer with 64GB RAM running at 3.8 GHz.
This workflow used 34 GB RAM and took
RAM usage can be moderated by reducing the parallel core count.

```{r,packages}

suppressPackageStartupMessages({
  library("limma")
  library("eulerr")
  library("IlluminaHumanMethylation450kmanifest")
  library("IlluminaHumanMethylationEPICanno.ilm10b4.hg19")
  library("tictoc")
  library("mitch")
  library("kableExtra")
  library("beeswarm")
})

CORES=12

```

## Load data

* annotations

* probe sets

* gene sets

* design matrix

* mval matrix

```{r,annotation}

anno <- getAnnotation(IlluminaHumanMethylationEPICanno.ilm10b4.hg19)
myann <- data.frame(anno[,c("UCSC_RefGene_Name","Regulatory_Feature_Group","Islands_Name","Relation_to_Island")])

gp <- myann[,"UCSC_RefGene_Name",drop=FALSE]
gp2 <- strsplit(gp$UCSC_RefGene_Name,";")
names(gp2) <- rownames(gp)
sets <- split(rep(names(gp2), lengths(gp2)), unlist(gp2))

summary(unlist(lapply(sets,length)))

genesets <- gmt_import("https://ziemann-lab.net/public/gmea_prototype/ReactomePathways.gmt")

if (!file.exists("GSE158422_design.rds")) {
  download.file("https://ziemann-lab.net/public/gmea_prototype/GSE158422_design.rds", "GSE158422_design.rds")
}
design <- readRDS("GSE158422_design.rds")

if (!file.exists("GSE158422_design.rds")) {
 download.file("https://ziemann-lab.net/public/gmea_prototype/GSE158422_mx.rds","GSE158422_mx.rds")
}
mval <- readRDS("GSE158422_mx.rds")

```

Reactome pathways were downloaded on the 14th Sept 2023 from MsigDB.

```{r,gsdl}

gs_entrez <- gmt_import("c2.cp.reactome.v2023.1.Hs.entrez.gmt")

gs_symbols <- gmt_import("c2.cp.reactome.v2023.1.Hs.symbols.gmt")

```

## GMEA 

There are two obvious ways to perform GMEA:

1. limma-agg-1stt (la1).
In this approach, the limma test is conducted on probes, followed by aggregation of the differential
methylation t-scores. Each gene gets a median t-stat value which is evaluated downstream by a 1 sample
t-test.

2. agg-limma-1stt (al1).
Here, the probe beta values for each gene are aggregated to a median and then limma is run on these
values.
To determine gene set enrichment, a 1-sample t-test is conducted.

## LA: limma aggregate 1-sample t-test

```{r,probelimma1}

sex <- as.data.frame(design)$sex
tumor <- as.data.frame(design)$tumor
patient <- as.character(unlist(lapply(1:ncol(mval),function(i) {c(i,i)})))
patient <- head(patient,ncol(mval))
design <- model.matrix(~ patient + tumor )

fit.reduced <- lmFit(mval,design)
fit.reduced <- eBayes(fit.reduced)
summary(decideTests(fit.reduced))
dm <- topTable(fit.reduced,coef=4, number = Inf)
dm <- merge(myann,dm,by=0)
dm <- dm[order(dm$P.Value),]
rownames(dm) <- dm$Row.names
dm$Row.names=NULL

head(dma) %>%
  kbl(caption="Top DM probes") %>%
  kable_styling("hover",full_width=FALSE)

agg <- function(dm,cores=1) {
  gn <- unique(unlist(strsplit( dm$UCSC_RefGene_Name ,";")))
  gnl <- strsplit( dm$UCSC_RefGene_Name ,";")
  gnl <- mclapply(gnl,unique,mc.cores=cores)
  dm$UCSC_RefGene_Name <- gnl
  l <- mclapply(1:nrow(dm), function(i) {
    a <- dm[i,]
    len <- length(a[[1]][[1]])
    tvals <- as.numeric(rep(a["t"],len))
    genes <- a[[1]][[1]]
    data.frame(genes,tvals)
  },mc.cores=cores)
  df <- do.call(rbind,l)
  keep <- names(which(table(df$genes)>1))
  df <- df[df$genes %in% keep,]
  gn <- unique(df$genes)
  gme_res <- lapply( 1:length(gn), function(i) {
    g <- gn[i]
    tstats <- df[which(df$genes==g),"tvals"]
    myn <- length(tstats)
    mymean <- mean(tstats)
    mymedian <- median(tstats)
    if ( length(tstats) > 2 ) {
      ttest <- t.test(tstats)
      pval <- ttest$p.value
    } else {
      pval = 1
    }
    res <- c("gene"=g,"nprobes"=myn,"mean"=mymean,
      "median"=mymedian, pval=pval)
  } )
  gme_res_df <- do.call(rbind, gme_res)
  rownames(gme_res_df) <- gme_res_df[,1]
  gme_res_df <- gme_res_df[,-1]
  tmp <- apply(gme_res_df,2,as.numeric)
  rownames(tmp) <- rownames(gme_res_df)
  gme_res_df <- as.data.frame(tmp)
  gme_res_df$sig <- -log10(gme_res_df[,4])
  gme_res_df <- gme_res_df[order(-gme_res_df$sig),]
  gme_res_df$fdr <- p.adjust(gme_res_df$pval)
  out <- list("df"=df,"gme_res_df"=gme_res_df)
  return(out)
}

tic()
dmagg <- agg(dm,cores=CORES)
toc()

head(dmagg$gme_res_df,20) %>%
  kbl(caption="top gmea genes (t-test)") %>%
  kable_paper("hover", full_width = F)

```

Check whether the distribution is even - it's not.

```{r,tmeddist}

hist(dmagg$gme_res_df$median,breaks=30) ; grid()

```

1-sample t-test for gene set enrichment.

```{r,t_enrichment_test1}

ttenrich <- function(m,genesets,cores=1) {
  res <- mclapply( 1:length(genesets), function(i) {
    gs <- genesets[i]
    name <- names(gs)
    n_members <- length(which(rownames(m) %in% gs[[1]]))
    if ( n_members > 4 ) {
      tstats <- m[which(rownames(m) %in% gs[[1]]),]
      myn <- length(tstats)
      mymean <- mean(tstats)
      mymedian <- median(tstats)
      wt <- t.test(tstats)
      res <- c(name,myn,mymean,mymedian,wt$p.value)
    }
  } , mc.cores = cores)
  res_df <- do.call(rbind, res)
  rownames(res_df) <- res_df[,1]
  res_df <- res_df[,-1]
  colnames(res_df) <- c("n_genes","t_mean","t_median","pval")
  tmp <- apply(res_df,2,as.numeric)
  rownames(tmp) <- rownames(res_df)
  res_df <- tmp
  res_df <- as.data.frame(res_df)
  res_df <- res_df[order(res_df$pval),]
  res_df$logp <- -log10(res_df$pval )
  res_df$fdr <- p.adjust(res_df$pval,method="fdr")
  res_df[order(abs(res_df$pval)),]
  return(res_df)
}

# need to get the median column before analysis
m <- dmagg$gme_res_df[,"median",drop=FALSE]

tic()
lares <- ttenrich(m=m,genesets=gs_symbols,cores=CORES)
toc()

head(lares,30) %>%
  kbl(caption = "Top significant genesets using LA approach") %>%
  kable_paper("hover", full_width = F)

head(lares[order(-abs(lares$t_median)),],30) %>%
  kbl(caption = "Top effect size genesets using LA approach") %>%
  kable_paper("hover", full_width = F)

lasig <- subset(lares,fdr<0.05)
nrow(lasig)

head(lasig[order(-abs(lasig$t_median)),],30) %>%
  kbl(caption = "Top effect size genesets after FDR filtering using LA approach") %>%
  kable_paper("hover", full_width = F)

plot(lares$t_median,-log10(lares$pval),pch=19,col="gray")
grid()
points(lasig$t_median,-log10(lasig$pval),pch=19,col="red")

```

## AL: Aggregate limma t-test

Determine the median of probe values

```{r,med1}

mx <- mval

gn <- unique(unlist(strsplit( myann$UCSC_RefGene_Name ,";")))
gnl <- strsplit( myann$UCSC_RefGene_Name ,";")
gnl <- mclapply(gnl,unique,mc.cores=CORES)
myann$gnl <- gnl

mymed <- function(g) {
  probes <- rownames(myann[grep(g,myann$gnl),])
  rows <- which(rownames(mx) %in% probes)
  if ( length(rows) > 1 ) {
    b <- mx[rows,]
    med <- apply(b,2,median)
    med <- matrix(med,nrow=1)
    colnames(med) <- colnames(b)
    rownames(med) <- g
    return(med)
  }
}

med <- mclapply(gn,mymed,mc.cores=CORES)
med <- med[lapply(med,length)>0]
medf <- do.call(rbind,med)

```

Then do a limma test on median gene methylation.
See if it is more robust than other approaches.

```{r,limma1}

fit.reduced <- lmFit(medf,design)
fit.reduced <- eBayes(fit.reduced)
summary(decideTests(fit.reduced))
magg <- topTable(fit.reduced,coef=ncol(design), number = Inf)

#write.table(dma3a,file="dma3a.tsv")

head(magg, 30) %>%
  kbl(caption="limma gene methylation results") %>%
  kable_paper("hover", full_width = F)

```

1-sample t-test for enrichment

```{r,ttest}

ttenrich <- function(m,genesets,cores=1) {
  res <- mclapply( 1:length(genesets), function(i) {
    gs <- genesets[i]
    name <- names(gs)
    n_members <- length(which(rownames(m) %in% gs[[1]]))
    if ( n_members > 4 ) {
      tstats <- m[which(rownames(m) %in% gs[[1]]),]
      myn <- length(tstats)
      mymean <- mean(tstats)
      mymedian <- median(tstats)
      wt <- t.test(tstats)
      pval = wt$p.value
      res <- c(name,myn,mymean,mymedian,pval)
    }
  } , mc.cores = cores)
  res_df <- do.call(rbind, res)
  rownames(res_df) <- res_df[,1]
  res_df <- res_df[,-1]
  colnames(res_df) <- c("n_genes","t_mean","t_median","pval")
  tmp <- apply(res_df,2,as.numeric)
  rownames(tmp) <- rownames(res_df)
  res_df <- tmp
  res_df <- as.data.frame(res_df)
  res_df <- res_df[order(res_df$pval),]
  res_df$logp <- -log10(res_df$pval )
  res_df$fdr <- p.adjust(res_df$pval,method="fdr")
  res_df[order(abs(res_df$pval)),]
  return(res_df)
}

m <- as.data.frame(magg$t)
rownames(m) <- rownames(magg)
colnames(m) <- "t"

alres <- ttenrich(m=m,genesets=gs_symbols,cores=CORES)

alsig <- subset(alres,fdr<0.05)

nrow(alsig)

nrow(subset(alsig,t_median>0))

head(alsig[order(-alsig$t_median),],20) %>%
  kbl(caption="hypermethylated pathways") %>%
  kable_paper("hover", full_width = F)

nrow(subset(alsig,t_median<0))

head(alsig[order(alsig$t_median),],20) %>%
  kbl(caption="hypomethylated pathways") %>%
  kable_paper("hover", full_width = F)

```

## Overlap

Use Euler diagrams to find the similarity.
As medians are normally distributed about the zero, one would expect equal numbers of up and down-
methylated gene sets.
Therefore the t-test based approach could be considered better.

```{r,ol1}

lasig_up <- rownames(subset(lasig,t_median>0))
lasig_dn <- rownames(subset(lasig,t_median<0))

alsig_up <- rownames(subset(alsig,t_median>0))
alsig_dn <- rownames(subset(alsig,t_median<0))

v1 <- list("LA up"=lasig_up, "LA dn"=lasig_dn,
  "AL up"=alsig_up,"AL dn"=alsig_dn)

plot(euler(v1),quantities = TRUE)

```

## Session information

```{r,save}

save.image("GSE158422_gmea.Rdata")

sessionInfo()

```
